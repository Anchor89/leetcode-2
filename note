Surrounded_Regions:
    take care of the boundary. block O next to boundery is not counted.

Palindrome_Partitioning:
    the initial value of m[0] should push_back an empty vector<string>
    not push_back a vector of {""}

Palindrome_Partitioning_II:
    don't forget to sort (i,j) while coding.
    write down steps before coding.

Longest_Consecutive_Sequence:
    link_jump, or union-set

Word_Ladder:
    O(n*len*26) bfs. don't think too complicate!

Valid Palindrome:
    numbers are belong to alphanumeric. use isalpha(c) and isdigit(c)

Binary_Tree_Maximum_Path_Sum:
    should return a valid path, include at least a node.
    if all node is negative, should not return 0.

Best_Time_To_Buy_and_Sell_Stock_III:
    if n < 2 return 0

Pascal'sTriangle:
    take care n = 0!
Pascal'sTriangle II:
    when n = 0, output the 1th row [1]

Populating Next Right Pointers in Each Node:
Populating Next Right Pointers in Each Node II:
    use the next point of last level
    
Binary Tree Level Order Traversal:
Binary Tree Level Order Traversal II:
    take care!!!

Symmetric Tree:
    How to solve it iteratorily?
    Initilize every variable when declare and use!
    
Recover Binary Search Tree:
    remember to return at the end of a function!
    
Validate Binary Search Tree:
    There should not be duplicate in a BST.

Interleaving String:
    if (s1.length() + s2.length() != s3.length()) return false;
    
Restore IP Addresse:
    when cut into small piece, take care of those start with 0

Reverse Linked List II:
    use for( ) instead of while (cnt++<n)

Decode Ways:
    take care of s.size() == 0!!

Scramble Stringï¼š
    read the problem carefully.
    
Partition List:
    use NodeList *p instead of NodeList* p;
    consider every pointer that could be NULL
    
Largest Rectangle in Histogram:
    if could not find one that is lower than height[i], then l[i] = -1, but r[i] = n

Remove Duplicates from Sorted List II:
    read the example!

Remove Duplicates from Sorted List:
    always take care of NULL pointer. consider
    1: whether a pointer could be NULL when initial, or the value is pass in
    2: when p = p->next, consider whether p could be NULL
    3: when remove some node of linklist, p->next could be NULL
